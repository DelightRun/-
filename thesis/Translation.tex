% Created 2016-05-19 Thu 21:41
\documentclass[UTF8]{ctexart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{王昌旭}
\date{2016 年 3 月 1 日}
\title{自然场景中文字的实时定位与识别}
\begin{document}

\maketitle

\section{摘要}

本文展示了一种对自然场景中的文字进行实时定位和是别的方法。实时性通过将文字检测任务变为一系列极值区域的选择来实现。
基于极值区域的检测器对模糊、光照、颜色和纹理变换有着极强的鲁棒性，并能处理低对比度图像。

在识别的第一阶段，我们使用对每个极值区域使用一些可在$O(1)$的时间复杂度内被计算出的全新特征来计算该极值区域为一个字符的概率。
只有那些具有局部极大概率的极值区域区域被选中并进入第二阶段——使用更加复杂的特征来计算更加准确的概率。
然后我们使用一种十分有效且带有反馈的搜索算法将这些极值区域区域聚合成单词并进行字符分割。最后，我们使用 OCR 的方法对这些字符进行识别。

我们在两个公开数据集上对算法进行了评估。在 ICDAR 2011 数据集上，与目前所有以公开的算法相比，我们的方法取得了目前为止最佳的字符定位效果。
在更具有挑战性的街景数据集上，我们的方法取得了目前为止最高的召回率。

\section{研究现状}

已有一系列用于解决自然场景中字符定位问题的方法被提出。如Epstein等人提出将图像转
换为灰度图后使用Canny算子来检测字符边缘。对每个像素，其平行的边缘被用于计算笔画
粗细，最后具有相似笔画粗细的像素悲剧和为一个个字符。该方法由于其依赖于边缘检测的
效果，因此对噪声和图像模糊十分敏感。此外还有其他人提出了一种同样使用边缘检测但使
用不同连通分量的算法。这些方法都可以在ICDAR Robust Reading竞赛结果中找到。

只有很少数能同时解决字符定位和识别的算法被提出。比如Wang等人的方法使用滑动窗口来
寻找独立的字符，然后使用词汇表将字符聚合成单词。这种方法可以可以处理带有噪声的数
据，但是其效果却受制于词汇表的大小。

还有一类基于极大稳定极值区域（MSER）对字符进行检测的方法，最终并基于MSER完成字符
分割以进行字符识别。MSER是极值区域的一种特殊情况，其在一段连续的阈值变化中保持面
积的不变。这类方法有着一般具有十分好的效果，但是却无法在模糊或低对比度的图像上正
常工作。根据ICDAR 2011 Robust Reading竞赛组织者提供的描述，最终竞赛的赢家正是基
于MSER的检测算法，但是这种方法还未被公布并且它不包括字符识别。

本文提出的方法与基于MSER的方法的不同之处在于，它将测试所有的极值区域（并非MSER的
一个子集）同时在保持和MSER相同的计算复杂度的基础上减少了内存占用，并可以达到实时
级的速度。本方法借鉴Zimermann等人的思想，放弃MSER中对极大稳定的要求，并选择一种
基于分类的极值区域(CSER)。在我们的方法中，实时地选择合适极值区域的工作通过一系列
级联分类器实现，并在此过程中使用了一些全新的特征，这些特征专门设计用来进行字符检
测。此外，分类器将被训练输出区域为字符的概率，因此可以被用于提取一个字符的多个分割。

\section{简介}

真实场景中的字符定位和识别在许多计算机视觉技术的应用中都是十分关键的一个环节，如基于文本的图像搜索、街景应用中对商店的标记识别以及虚拟现实系统，
因此一直是计算机世界研究的热点。在过去的几年中，举行了许多相关竞赛，但即使是目前最好的方法在也只在 ICDAR 2011 竞赛中取得了 62\% 的定位准确率，
并且该数据集并不能代表真实场景（数据集中的单词全部是水平的，并在图像用占据主要位置，没有投影变换或比较显著的噪声）。

在图像中定位文字区域很可能是一个十分耗费计算资源的任务，因为一幅图像中一共有$2^N$个可能为文字区域的子集（$N$为像素数量）。
因此主流文字定位算法在解决此问题是可分为两种思路。

一类方法通过滑动窗口将搜索区域限制在图像的一个子区域内。这类方法将对图像的搜索复杂度降至了$cN$级别，其中$c$是一个常数，代表算法所需处理不同放缩比、长宽比、旋转等变换的种类。

另一类方法通过连通分量分析将像素聚合成字符区域，这类方法假定属于同一个字符的像素有着相似的属性。连通分量分析方法又根据使用属性的不同分为许多种（如颜色、比划粗细等）。
基于连通分量的方法的优点在于其算法复杂度不依赖于文字区域的属性（如尺寸、旋转、字体）等，并且提供了对字符的分割操作以方便进行 OCR。但是这类方法也有其缺点，具体来讲就是对会
连通分量产生改变的干扰十分敏感，如干扰、阻隔等。

在本文中，我们提出了一种端到端的实时文字定位和识别算法，该方法在标准数据集上取得了目前最佳的效果。实时性通过将文字检测任务变为一系列极值区域的选择来实现。
基于极值区域的检测器对模糊、光照、颜色和纹理变换有着极强的鲁棒性，并能处理低对比度图像。这种算法的复杂度是$O(2pN)$，其中\$p\$表示使用的通道（投影）数。


在识别的第一阶段，我们使用对每个极值区域使用一些可在$O(1)$的时间复杂度内被计算出的全新特征来计算该极值区域为一个字符的概率。
只有那些具有局部极大概率的极值区域区域被选中并进入第二阶段——使用更加复杂的特征来计算更加准确的概率。
然后我们使用一种十分有效且带有反馈的搜索算法将这些极值区域区域聚合成单词并进行字符分割。

此外，我们提出一种全新的梯度幅度投影来检测图像边缘并计算 极值区域。进一步的测试表明使用梯度投影后，极值区域 检测器能检测出 94.8\%的字符。

\section{本文提出的算法}

\subsection{极值区域}

我们首先定义一幅图像$\mathbf{I}$为一个映射$\mathbf{I} : \mathcal{D} \subset
\mathbb{N}^2 \rightarrow \mathcal{V}$，其中$\mathcal{V}$一般为
$\{0,\cdots,255\}^3$（即一个色彩空间）。然后，我们定义图像的一个通道为
$\mathbf{C} : \mathcal{D} \rightarrow \mathcal{S}$，其中\$\mathcal{S}\$为一个全序
集并且存在一个映射$f_c : \mathcal{V} \rightarrow \mathbf{S}$将像素值映射到该全序
集。我们定义$A$为邻接关系$A \subset \mathcal{D} \times \mathcal{D}$，常见的邻接
关系有 4-邻接和 8-邻接，在本章的实现中我们使用 4-邻接关系。

我们定义图像$I$（或通道$C$）的一个 Region 为$\mathcal{D}$的一个连续子集（所为连续，
是指$\forall{p_i, p_j \in \mathcal{R}}\, \exists{p_i, q_1, q_2, \cdots, q_n,
  p_j} : p_iAq_1, q_1Aq_2,\cdots,q_nAp_j$。我们定义 Region 边界
$\partial{\mathcal{R}}$ 为那些与 Region $\mathcal{R}$邻接却不属于$\mathcal{R}$的像
素的集合，即$\partial{\mathcal{R}} = \{p \in \mathcal{D} \\ \mathcal{R} :
\exists{q \in \mathcal{R}} : pAq \}$。现在，我们定义 \textit{极值区域} (极值区域)
为那些边界像素值比内部像素高许多的 Region，写成数学语言即$ \forall{p \in
  \mathcal{R}}, q \in \partial{\mathcal{R}} : \mathbf{C}(q) > \theta > \mathbf{C}(p)$，其中
$\theta$为极值区域的阈值。

一个阈值为$\theta$的极值区域$r$可以由多个或
个阈值为$\theta - 1$的极值区域和值为$\theta$的像素和并集：$r = \left( \bigcup{u \in
    R_{\theta-1}} \right) \cup \left( \bigcup{p \ in \mathcal{D} : \mathbf{C}(p)
  = \theta} \right)$构成，其中$R_{\theta-1}$表示阈值为$\theta_1$的极值区域。
该性质指出极值区域 间有一种包含关系，一个极值区域可以包含一个或多个后继 极值区域（或没有后继，如果它只包含具有相同值的像素）
和唯一的前驱 极值区域。

在本文中，我们考虑 RGB 和 HSI 色彩空间，并且额外使用一个 \emph{亮度导数} 通道，其中每个像素的导数通过
该像素及其邻域像素的最大亮度差来表示：

\[
\mathbf{C}_{\nabla}(p) = \max_{\q \in \mathcal{D} : pAq}{\|\mathbf{C}_{\{\mathbf{I}}(p) - \mathbf{C}_\mathbf{I}(q) \| \}}
\]

实验验证表明 85.6\%的字符可通过在一个通道上的极值区域检测，94.8\%的字符区域可以通过所有通道检测。
一个字符被认为被成功地检测到，如果极值区域的边界矩形和真实字符边界矩形有 90\%的重合。在我们提出的方法中，我们结合使用亮度（I）、
亮度导数（$\nabla$）、色度（H）和饱和度（S）通道进行实验，并在运行时间和定位准确率之间取得了最佳的平衡。

\subsection{可增量计算描述子}

能够对极值区域进行快速分类的关键在于能快速对每个区域计算其描述子作为分类器的特征。正如 Zimmerman 和 Matas 在他们论文中所提出的，
我们可以使用一类特殊的描述子，这类描述字可以根据极值区域见的包含关系逐步递增地计算得出。

我们使用$R_{\theta-1}$表示阈值为$\theta-1$的 极值区域。一个极值区域 $r \in R_{\theta}$科表示为一系列阈值为$\theta-1$的极值区域的并集并加上一些值为$\theta$的像素。
我们进一步假设对于每个阈值为$\theta-1$的 极值区域$u \in R_{\theta-1}$其描述子$\phi(u)$已知。为了计算描述子$\phi(r), r \in R_{\theta}$，我们必须结合那些组成$r$的
极值区域$u \in R_{\theta-1}$的描述子和值为$\theta$的像素，即$\phi(r) = \left( \oplus{\phi(u)} \right) \oplus \left( \oplus{\psi(p)} \right)$，其中$\oplus$表示对描述子进行结合的算子，
$\psi(p)$被称为初始化函数，用于计算给定像素$p$的描述子。我们将那些存在$\psi(p)$
和$\oplus$的描述子称为\textit{可增量计算的}。

显然，我们可以通过将阈值$\theta$从 0 逐步累加之 255 的方法来计算出所有极值区域的描述子，即计算值为$\theta$的像素的描述子$\psi$并重用那些阈值为$\theta-1$的区域的描述子$\phi$。
注意，这种性质指出我们只需要在内存中保留前一阈值所对用极值区域区域的描述子，因
此这种方法相较于基于极大稳定极值区域的方法将极大程度减少内存占用。更进一步，如果我们假设初始化函数$\psi$和结合算子$\oplus$
具有常数级别的计算复杂度，则计算所有极值区域区域的算法复杂度仅有$O(N)$。

在本文中，我们使用下述描述子： 

\begin{itemize}
\item \textbf{面积} $a$：极值区域 区域的面积（即像素数量）。其初始化函数为一个常数
  $\psi(p)=1$，结合算子$\oplus$为数值加法。
\item \textbf{边框} $(x_{min}, y_{min}, x_{max}, y_{max})$：即极值区域边框的右上角和
  左下角。对于坐标为$(x,y)$d 的像素$p$，其初始化函数为四元组$(x,y,x+1,y+1)$，结
  合算子$\oplus$为$(min,min,max,max)$。区域的长和宽可通过$x_{max}-x_{min}$和
  $y_{max}-y_{min}$计算得到。
\item \textbf{周长} $p$：即极值区域边缘的长度。初始化函数$\psi(p)$通过新加入值为
  $\theta$的像素的位置来绝对周长的改变量，结合算子$\oplus$为数值加法。$\psi(p)$
  的时间复杂度为$O(1)$，因为一个像素最多只有四个邻居。
\item \textbf{欧拉数$\eta$}：欧拉数是二值图像的一种拓扑特征，为连通域数目和孔洞。
\item \textbf{水平交叉点数$c_i$}：用一个长度为图像高度的向量来保存对应行像素在属
  于极值区域与不属于极值区域 之间转变的次数。初始化函数的的值由在阈值$\mathbf{C}(p)$下像素p
  的左右邻接像素的存在与否来定。结合算子$\oplus$为按元素做加法。$\psi(p)$的计
  算复杂度是个常数（每个像素在水平方向至多只有两个邻居），并且按元素的加法可以
  也具有常数复杂度，因为假定使用的数据结构的随机访问和两端插入操作的复杂度为
  O(1)(如双端队列)。
\end{itemize}

\subsection{级联分类器}

在我们提出的方法中，每个通道被分别进行迭代（原始通道和反色通道）然后检测极值区域。为了
减少极高的假阳性率以及减少的极值区域，只有那些被分类器认为十分可能是字符的极值区域区域被保留。
为了提高计算性能，分类阶段被分为两阶段进行。

在第一阶段，阈值从0逐步累加至255，对每个极值区域$r$计算其可增量计算描述子并作为特征送
入分类器，得到该极值区域为字符区域的条件概率$p(r\|字符)$。概率$p(r\|字符)$在贯穿
所有阈值的极值区域级联推倒中备注总，并且只有那些具有局部极大概率的极值区域会被选
中（即局部极大概率大于全局阈值 $p_{min}$ 并且局部极大和局部极小的差大于
$\Delta_{min}$）。

在本文中，我们使用一个基于决策树的AdaBoost分类器并使用特征：

\begin{itemize}
\item \textbf{长宽比}($w/h$)
\item \textbf{compactness}($\sqrt{a}/p$)
\item \textbf{孔洞数}($1-\eta$)
\item \textbf{水平交叉点特征}($\hat{c}=median(\mathbf{c}_{\frac{1}{6}w}, \mathbf{c}_{\frac{3}{6}w}, \mathbf{c}_{\frac{5}{6}w})$)
\end{itemize}

因为只有$\mathbf{c}$的一个固定子集被使用，所以具有常数时间复杂度。分类器的输出通
过对数几率回归得到概率分布函数$p(r\|字符)$。在实验中我们使用参数$p_{min} = 0.2$
和$\Delta_{min}=0.1$来获得更高的召回率(95.6\%)。

在第二阶段，通过第一阶段的极值区域被分为字符和非字符两类，并使用了有更多欣喜但也
更耗费计算资源特征。在本文中，使用了一个具有RBF核的SVM分类器。该分类器除了上述第
一阶段用到的特征外，还是额外使用了如下特征：

\begin{itemize}
\item \textbf{孔洞面积比$a_h/a$}：其中$a_h$代表ER 区域内孔洞的面积（像素数）。
\item \textbf{凸包面积比$a_c/a$}：其中$a_c$为ER 区域凸包的面积。
\item \textbf{外轮廓拐点数$\kappa$}：代表ER 区域边界凹角与凸角的变化数目。一个字
  符一般只含有数量比较少的外轮廓拐点（$kappa < 10$），而非字符区域（如草）则含有
  大量的外轮廓拐点。
\end{itemize}

我们注意到，以上所有特征都是放缩不变的，但不是旋转不变的，因此我们的训练集中需要
包含具有不同旋转角度的字符。

\section{结论}

本文提出了一种端到端的实时文字定位和识别算法。在分类的第一阶段，我们使用一系列全
新的可在$O(1)$复杂度内被计算出的特征来计算极值区域为字符的概率，并且只有具有局部
极大概率的极值区域被选中并进入第二阶段，在第二阶段我们使用一些更加耗费计算资源的
特征进行更准确地分类。。实验指出，包括全新的梯度幅度投影后极值区域可以覆盖94.8\%
的字符。本算法在$800 \times 600$的图像上平均计算时间为0.3s（使用普通PC）。

本算法在两个公共数据集上进行了评估。在ICDAR 2011数据集上，该方法在所有已公开的算
法中取得了目前最好的字符定位效果（召回率64.7\%，准确率73.1\%，f-测度 68.7\%），
并且我们是在ICAD 2011 Robust Reading 比赛数据集中第一个提交端到端字符识别结果的
系统（召回率37.2\%，精度37.1\%，f-测度 36.5\%）。

在更具有挑战性的街景文字数据集上，文字定位的召回率为32.9\%。但是，我们并没有可以
进行直接比较的结果，因此也无从得知结果优劣。

\end{document}